#!/bin/bash

set -e # XXX

VERSION=1.0.0

# configs
IAM=$(basename $0)
EXTRACTED=extracted
ROOTFS=rootfs.cpio
SNIPPET_BASE=$HOME/$IAM # https://github.com/smallkirby/snippet
QEMUSCRIPT=run.sh

QEMUSCRIPT_CANDS=( "run" "start" )

# includes
source "$(realpath $(dirname $0))/includes/errors"
source "$(realpath $(dirname $0))/includes/configer"
source "$(realpath $(dirname $0))/includes/utils"
source "$(realpath $(dirname $0))/includes/exploit"
source "$(realpath $(dirname $0))/includes/gitter"
source "$(realpath $(dirname $0))/includes/drothea-client"

function compress_filesystem() {
  echo "[+] re-compressing filesystem..."
  if ! [ -d "$EXTRACTED" ]; then
    _error_exit $FILE_NOT_FOUND "directry '$EXTRACTED' not found"
  fi
  rm -f $ROOTFS
  chmod 777 -R $EXTRACTED
  cd $EXTRACTED
  find ./ -print0 | cpio --owner root --null -o --format=newc >../$ROOTFS || _error_exit $UNKNOWN_ERROR "failed to compress rootfs"
  cd ../
}

function init() {
  echo "[+] initiating pwn workspace..."

  local KBASE=$SNIPPET_BASE/assets
  local TARGETS=("exploit.c exploit.h extract-vmlinux.sh sender.py") # targets under `assets`

  # raw copy of assets
  for target in ${TARGETS[@]}; do
    if [ -f $target ]; then
      printf "[-] %s already exists, skipping. \n" "$target"
    else
      printf "[.] copying %s\n" "$target"
      cp "$KBASE/$target" ./ || _error_exit "$OPERATION_FAILED" "copy failed."
    fi
  done

  # copy Drothea
  local DROTHEA=$SNIPPET_BASE/drothea
  if [ -f drothea ]; then
    echo "[-] drothea already exists, skipping."
  else
    echo "[.] copying drothea"
    cp "$DROTHEA/drothea" ./ || _error_exit "$OPERATION_FAILED" "copy failed"
  fi

  # compile Ingrit and copy
  if [ -f ingrid ]; then
    echo "[.] ingrid already exists, skipping"
  else
    echo "[.] compiling and copying ingrid"
    local INGRID=$SNIPPET_BASE/drothea/ingrid
    make -C "$INGRID" || _error_exit "$COMPILE_ERROR" "failed to build Ingrid"
    cp "$INGRID/ingrid" ./ || _error_exit "$OPERATION_FAILED" "copy failed"
  fi

  # copy QEMU run script
  local qemu_candidates
  for word in "${QEMUSCRIPT_CANDS[@]}"; do
    readarray -t tmp_cands < <(find . -maxdepth 1 -type f -name "$word*.*" | grep -v dev)
    qemu_candidates+=( "${tmp_cands[@]}" )
  done
  if [ "${#qemu_candidates[@]}" -ge 1 ]; then
    local qemu_runscript="${qemu_candidates[0]}"
    QEMUSCRIPT="$qemu_runscript".dev
    if ! [ -f "$QEMUSCRIPT" ]; then
      printf "[+] found %d QEMU run-script candidates: %s\n" "${#qemu_candidates[@]}" "${qemu_candidates[*]}"
      printf "[+] copying %s -> %s\n" "$qemu_runscript" "$QEMUSCRIPT"
      cp "$qemu_runscript" "$QEMUSCRIPT"

      vprintf "[.] setting config: %s=%s" "QEMUSCRIPT" "$QEMUSCRIPT"
      write_config "QEMUSCRIPT" "$QEMUSCRIPT"
    fi
  fi

  init_git

  return 0
}

# $1: force replace
function extract_filesystem() {
  if [ $# -ge 2 ]; then
    _error_exit $INVALID_ARGS "invalid # of args passed to extract_filesystem()."
    return 1
  fi

  if [ "$1" = 1 ]; then
    local FORCE_EXTRACT=1
  fi

  if ! [ -f $ROOTFS ]; then
    _error_exit $FILE_NOT_FOUND "filesystem '$ROOTFS' not found."
    return 2
  fi

  if [ -d $EXTRACTED ]; then
    if [ -z "$FORCE_EXTRACT" ] || [ $FORCE_EXTRACT -ne 1 ]; then
      _error_exit $FILE_ALREADY_EXIST "directory '$EXTRACTED' already exists. Specify '--force' to replace it."
    else
      echo "[+] Removing $EXTRACTED."
      sudo rm -rf $EXTRACTED || _error_exit $SUDO_NOT_ALLOWED "failed to remove directory."
    fi
  fi

  echo "[+] Extracting filesystem into '$EXTRACTED'"
  mkdir $EXTRACTED
  filetype=$(file $ROOTFS)

  cd $EXTRACTED || return 3
  if [[ $filetype == *"gzip"* ]]; then
    echo "[+] found gzipped file system."
    zcat $ROOTFS | cpio -idmv
  else
    cpio -idv 2>/dev/null <../$ROOTFS
  fi

  if [ $? -eq 0 ]; then
    echo "[+] extraction success"
  fi
  cd ../
  return 0
}

function _set_command() {
  if [ -n "$COMMAND" ]; then
    _error_exit $INVALID_ARGS "multiple commands are specified: '%s' and '%s'" "$COMMAND" "$1"
  else
    COMMAND=$1
    return 0
  fi
}

function log_parse_arguments() {
  local num_processed=0
  while [[ $# -gt 0 ]]; do
    key="$1"

    case $key in
      --all)
        SHOW_ALL_LOG=1
        shift
        num_processed=$((num_processed+1))
        ;;
      --no-pager)
        SHOW_LOG_NO_PAGER=1
        shift
        num_processed=$((num_processed+1))
        ;;
      *)
        if [[ "$1" =~ ^[0-9]+$ ]]; then
          LOG_TARGET_INDEX="$1"
          shift
          num_processed=$((num_processed+1))
        else
          break
        fi
        ;;
    esac
  done

  NUM_ARGUMENTS_PROCESSED=$num_processed
}

function remote_parse_arguments() {
  local num_processed=0
  while [[ $# -gt 0 ]]; do
    key="$1"

    case $key in
      -p | --port)
        shift
        EXPLOIT_PORT="$1"
        write_config "EXPLOIT_PORT" "$EXPLOIT_PORT"
        shift
        num_processed=$((num_processed+2))
        ;;
      -H | --host)
        shift
        EXPLOIT_HOST="$1"
        write_config "EXPLOIT_HOST" "$EXPLOIT_HOST"
        shift
        num_processed=$((num_processed+2))
        ;;
      --nobuild)
        EXPLOIT_SKIP_BUILD=1
        shift
        num_processed=$((num_processed+1))
        ;;
      *)
        break
        ;;
    esac
  done

  NUM_ARGUMENTS_PROCESSED=$num_processed
}

function parse_arguments() {
  while [[ $# -gt 0 ]]; do
    key="$1"

    case $key in
    # generic options
    -h | --help | help)
      HELP=1
      return 0
      ;;
    -v | --verbose)
      VERBOSE=1
      shift
      ;;
    -f | --force)
      FORCE=1
      shift
      ;;
    --nolog)
      EXPLOIT_DONT_LOG=1
      shift
      ;;

    # commands
    version)
      SHOW_VERSION=1
      return 0
    ;;
    init)
      _set_command init
      shift
      ;;
    extract)
      _set_command extract
      shift
      ;;
    build)
      _set_command build
      shift
      ;;
    compress)
      _set_command compress
      shift
      ;;
    error | -e)
      _set_command error
      shift
      ERROR_ASKED=$1
      shift
      ;;
    exploit | local)
      _set_command exploit
      shift
      EXPLOIT_LOCAL=1

      NUM_ARGUMENTS_PROCESSED=0
      remote_parse_arguments "$@"
      shift "$NUM_ARGUMENTS_PROCESSED"
      ;;
    remote)
      _set_command exploit
      shift
      NUM_ARGUMENTS_PROCESSED=0
      remote_parse_arguments "$@"
      shift "$NUM_ARGUMENTS_PROCESSED"
      ;;
    logs)
      _set_command logs
      shift
    ;;
    log)
      _set_command log
      shift
      NUM_ARGUMENTS_PROCESSED=0
      log_parse_arguments "$@"
      shift "$NUM_ARGUMENTS_PROCESSED"
    ;;
    fetch)
      _set_command fetch
      shift
      NUM_ARGUMENTS_PROCESSED=0
      log_parse_arguments "$@"
      shift "$NUM_ARGUMENTS_PROCESSED"
    ;;
    drothea)
      _set_command drothea
      shift
    ;;
    config)
      _set_command config
      shift
    ;;
    # unknown
    *)
      _error_exit $INVALID_ARGS "unknown command: %s" "$1"
      ;;
    esac
  done

  if [ -z "$COMMAND" ]; then
    _error_exit $INVALID_ARGS "command not specified"
  fi
}

function version() {
  printf "Lysithea v%s\n" "$VERSION"
}

function usage() {
  version
  echo ""
  echo "Usage:"
  printf "  init      : init the pwn workspace\n"
  printf "  extract   : extract filesystem\n"
  printf "  compress  : compress filesystem\n"
  printf "  run       : run QEMU\n"
  printf "  build     : compile exploit for local usage\n"
  printf "  error     : show error description\n"
  printf "  local     : run QEMU script\n"
  printf "  exploit   : synonym of 'local'\n"
  printf "  remote    : run exploit on remote host\n"
  printf "  logs      : show list of logs\n"
  printf "  log       : show QEMU log of given time\n"
  printf "  fetch     : fetch given time of exploit\n"
  printf "  drothea   : run kernel configuration checker in QEMU\n"
  printf "  config    : configure default options interactively\n"
  printf "  version   : show version info\n"
  printf "  help      : show this help\n"
}

function main() {
  set_all_configs
  local argv="$@"
  parse_arguments $argv

  if [ -n "$HELP" ]; then
    usage
    exit 0
  fi

  if [ -n "$SHOW_VERSION" ]; then
    version
    exit 0
  fi

  case $COMMAND in
  init)
    init
    ;;
  extract)
    extract_filesystem $FORCE
    ;;
  build)
    compile_exploit
    ;;
  compress)
    compress_filesystem
    ;;
  error)
    error2str $ERROR_ASKED
    ;;
  exploit)
    exploit
    ;;
  logs)
    list_logs
    ;;
  log)
    if [ -n "$SHOW_ALL_LOG" ]; then
      get_log_all
    else
      if [ -z "$LOG_TARGET_INDEX" ]; then
        _error_exit "$INVALID_ARGS" "Specify log index, or use --all to show all logs."
      fi
      get_log_single "$LOG_TARGET_INDEX"
    fi
    ;;
  fetch)
    if [ -z "$LOG_TARGET_INDEX" ]; then
      _error_exit "$INVALID_ARGS" "Specify log index"
    fi
    get_exploit "$LOG_TARGET_INDEX"
    ;;
  drothea)
    run_drothea_in_qemu
    ;;
  config)
    configure_interactive
    ;;
  *)
    _error_exit $UNKNOWN_ERROR "command not found."
    ;;
  esac

  exit 0
}

main "$@"
